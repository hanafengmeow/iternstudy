/* (C) 2024 */
package com.quick.immi.ai.service;

import static com.quick.immi.ai.entity.GenerationType.USER_UPLOADED;

import com.google.gson.Gson;
import com.quick.immi.ai.constant.Prompt;
import com.quick.immi.ai.dao.DocumentMapper;
import com.quick.immi.ai.dto.common.DocumentDto;
import com.quick.immi.ai.dto.request.GeneratePresignedUrlRequestDto;
import com.quick.immi.ai.dto.response.GeneratePresignedUrlResponseDto;
import com.quick.immi.ai.entity.*;
import com.quick.immi.ai.entity.document.MarriageCertificate;
import com.quick.immi.ai.entity.document.Passport;
import com.quick.immi.ai.service.helper.DocumentAnalysisService;
import com.quick.immi.ai.service.helper.EntityCacheService;
import com.quick.immi.ai.service.helper.OpenAIService;
import com.quick.immi.ai.service.helper.S3Service;
import com.quick.immi.ai.utils.DocumentServiceUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@Service
@Slf4j
public class DocumentMgtService {

  @Autowired private S3Service s3Service;

  @Autowired private DocumentMapper documentMapper;

  @Autowired private DocumentAnalysisService documentAnalysisService;

  @Autowired private OpenAIService openAIService;

  @Autowired private EntityCacheService entityCacheService;

  @Value("${com.quickimmi.user.profile-bucket}")
  private String userProfileBucket;

  @Value("${com.quickimmi.generated.document-bucket}")
  private String generatedDocumentBucket;

  public void updateDocumentStatus(Long id, TaskStatus documentStatus, Boolean manualOverride) {
    Document document =
        Document.builder()
            .id(id)
            .status(documentStatus.getValue())
            .manualOverridden(manualOverride)
            .updatedAt(System.currentTimeMillis())
            .build();
    documentMapper.update(document);
  }

  public GeneratePresignedUrlResponseDto generateUploadPresignedUrlForUpload(
      GeneratePresignedUrlRequestDto requestDto, Role role) {
    String fileType = DocumentServiceUtils.getFileType(requestDto.getDocumentName());
    Document document;
    String s3Key;
    DocumentType documentType = requestDto.getType();
    Optional<Document> existDocument =
        getExistDocument(requestDto.getCaseId(), documentType.getName(), requestDto.getIdentify());
    s3Key = getS3Key(requestDto.getUserId(), requestDto.getCaseId(), UUID.randomUUID().toString());

    if (existDocument.isPresent() && documentType.getOperation() == Operation.REPLACE) {
      log.info(String.format("replace the existing document for request %s", requestDto));
      document = existDocument.get();
      document.setS3Location(getS3Url(s3Key));
      document.setName(requestDto.getDocumentName());
      document.setFileType(fileType);
      document.setDescription(requestDto.getDescription());
      document.setStatus(TaskStatus.IN_PROGRESS.getValue());
      document.setUpdatedAt(System.currentTimeMillis());
      document.setManualOverridden(true);
      documentMapper.update(document);
    } else {
      document = createDocument(requestDto, fileType, s3Key, role, USER_UPLOADED);
    }

    entityCacheService.saveDocument(document.getId(), document);
    String presignedUrl = s3Service.generatePresignedUrlForUpload(userProfileBucket, s3Key);
    return new GeneratePresignedUrlResponseDto(document.getId(), presignedUrl);
  }

  private Document createDocument(
      GeneratePresignedUrlRequestDto requestDto,
      String fileType,
      String s3Key,
      Role role,
      GenerationType generationType) {
    Document document =
        Document.builder()
            .caseId(requestDto.getCaseId())
            .userId(requestDto.getUserId())
            .identify(requestDto.getIdentify().getValue())
            .type(requestDto.getType().getName())
            .fileType(fileType)
            .status(TaskStatus.IN_PROGRESS.getValue())
            .createdBy(role.getValue())
            .s3Location(getS3Url(s3Key))
            .name(requestDto.getDocumentName())
            .description(requestDto.getDescription())
            .autoGenerated(false)
            .createdAt(System.currentTimeMillis())
            .generationType(generationType.getValue())
            .build();
    documentMapper.create(document);
    return document;
  }

  // replace a document
  public String generateUploadPresignedUrlForUploadByDocumentId(
      GeneratePresignedUrlByDocumentIdRequestDto requestDto, Role role) {
    Document document = documentMapper.get(requestDto.getDocumentId());
    if (document == null) {
      throw new RuntimeException(
          String.format(
              "fail to generateUploadPresignedUrlForUpload because documentId %s doesn't exist",
              requestDto.getDocumentId()));
    }

    document.setName(requestDto.getDocumentName());
    document.setCreatedBy(role.getValue());
    document.setIdentify(requestDto.getIdentify().getValue());
    document.setType(requestDto.getType() != null ? requestDto.getType().getName() : null);
    document.setUpdatedAt(System.currentTimeMillis());
    document.setManualOverridden(true);
    document.setAutoGenerated(false);
    document.setStatus(TaskStatus.UPLOADING.getValue());
    String s3Key = s3Service.getS3KeyFromS3Location(document.getS3Location());
    String s3Bucket = s3Service.getS3BucketFromS3Location(document.getS3Location());
    documentMapper.update(document);

    String presignedUrl = s3Service.generatePresignedUrlForUpload(s3Bucket, s3Key);

    return presignedUrl;
  }

  public Optional<DocumentDto> get(Long documentId) {
    Document document = entityCacheService.getDocument(documentId);
    if (document == null) {
      document = documentMapper.get(documentId);
    }
    if (document == null) {
      return Optional.empty();
    }

    entityCacheService.saveDocument(documentId, document);

    String presignedUrl = s3Service.generatePresignedUrlForDownload(document.getS3Location());
    return Optional.of(
        DocumentDto.builder()
            .id(documentId)
            .name(document.getName())
            .identify(Identify.fromValue(document.getIdentify()))
            .createdAt(document.getCreatedAt())
            .updatedAt(document.getUpdatedAt())
            .autoGenerated(document.getAutoGenerated())
            .type(document.getType())
            .userId(document.getUserId())
            .presignUrl(presignedUrl)
            .status(document.getStatus())
            .build());
  }

  public Optional<Passport> parsePassport(Long documentId) {
    Document cacheDocument = entityCacheService.getDocument(documentId);
    if (cacheDocument == null) {
      cacheDocument = documentMapper.get(documentId);
    }
    if (cacheDocument == null) {
      return Optional.empty();
    }

    cacheDocument.setStatus(TaskStatus.SUCCESS.getValue());
    cacheDocument.setUpdatedAt(System.currentTimeMillis());

    documentMapper.update(cacheDocument);
    entityCacheService.saveDocument(documentId, cacheDocument);

    log.info(String.format("userProfileBucket == %s", userProfileBucket));

    String context =
        documentAnalysisService.parse(
            userProfileBucket, s3Service.getS3KeyFromS3Location(cacheDocument.getS3Location()));
    String query = String.format(Prompt.EXTRACT_PASSPORT_INFO_PROMPT, context);
    String result = openAIService.invoke(query);

    Passport passport = new Gson().fromJson(result, Passport.class);
    return Optional.of(passport);
  }

  public Optional<MarriageCertificate> parseMarriageLicense(Long documentId) {
    Document cacheDocument = entityCacheService.getDocument(documentId);
    if (cacheDocument == null) {
      cacheDocument = documentMapper.get(documentId);
    }
    if (cacheDocument == null) {
      return Optional.empty();
    }

    cacheDocument.setStatus(TaskStatus.SUCCESS.getValue());
    cacheDocument.setUpdatedAt(System.currentTimeMillis());

    documentMapper.update(cacheDocument);
    entityCacheService.saveDocument(documentId, cacheDocument);

    log.info(String.format("userProfileBucket == %s", userProfileBucket));

    String context =
        documentAnalysisService.parse(
            userProfileBucket, s3Service.getS3KeyFromS3Location(cacheDocument.getS3Location()));
    String query = String.format(Prompt.EXTRACT_MARRIAGE_LICENSE_INFO_PROMPT, context);
    String result = openAIService.invoke(query);

    MarriageCertificate marriageCertificate =
        new Gson().fromJson(result, MarriageCertificate.class);
    return Optional.of(marriageCertificate);
  }

  public String parseDocument(Long documentId) {
    Document document = documentMapper.get(documentId);
    document.setStatus(TaskStatus.SUCCESS.getValue());
    document.setUpdatedAt(System.currentTimeMillis());
    documentMapper.update(document);
    log.info(String.format("userProfileBucket == %s", userProfileBucket));
    String context =
        documentAnalysisService.parse(
            userProfileBucket, s3Service.getS3KeyFromS3Location(document.getS3Location()));
    String query = String.format(Prompt.EXTRACT_PASSPORT_INFO_PROMPT, context);
    String result = openAIService.invoke(query);

    return result;
  }

  // override existing document
  public Optional<Document> getExistDocument(Long caseId, String type, Identify identify) {
    List<Document> list = documentMapper.list(caseId, type, identify.getValue(), null, null);
    if (list == null || list.isEmpty()) {
      return Optional.empty();
    }
    return Optional.ofNullable(list.get(0));
  }

  // override existing document
  public Optional<List<Document>> getMultipleExistDocument(
      Long caseId, String type, Identify identify) {
    List<Document> list = documentMapper.list(caseId, type, identify.getValue(), null, null);
    if (list == null || list.isEmpty()) {
      return Optional.empty();
    }
    return Optional.ofNullable(list);
  }

  public List<DocumentDto> list(
      Long caseId, String type, String identify, Boolean autoGenerated, String generationType) {
    List<Document> list =
        documentMapper.list(caseId, type, identify, autoGenerated, generationType);
    List<DocumentDto> result = new ArrayList<>();
    if (CollectionUtils.isEmpty(list)) {
      return result;
    }

    for (Document document : list) {
      DocumentDto doc =
          DocumentDto.builder()
              .userId(document.getUserId())
              .id(document.getId())
              .type(document.getType())
              .generationType(document.getGenerationType())
              .identify(Identify.fromValue(document.getIdentify()))
              .caseId(document.getCaseId())
              .name(document.getName())
              .autoGenerated(document.getAutoGenerated())
              .manualOverridden(document.getManualOverridden())
              .status(document.getStatus())
              .createdAt(document.getCreatedAt())
              .createdBy(document.getCreatedBy())
              .updatedAt(document.getUpdatedAt())
              .build();
      result.add(doc);
    }

    return result;
  }

  public void delete(Long documentId) {
    documentMapper.delete(documentId);
  }

  public String getS3Url(String key) {
    return String.format("s3://%s/%s", userProfileBucket, key);
  }

  public String getS3Key(Integer userId, Long caseId, String name) {
    return String.format("%s/%s/%s", userId, caseId, name);
  }

  public Long createOrUpdateDocumentWithNewGeneration(
      Optional<Document> document,
      Long caseId,
      Integer userId,
      DocumentType documentType,
      GenerationType generationType) {
    if (document.isPresent()) {
      Document existDocument = document.get();

      existDocument.setStatus(TaskStatus.IN_PROGRESS.getValue());
      existDocument.setUpdatedAt(System.currentTimeMillis());
      existDocument.setCreatedAt(System.currentTimeMillis());
      existDocument.setCreatedBy(Role.SYSTEM.getValue());
      existDocument.setGenerationType(generationType.getValue());
      existDocument.setManualOverridden(false);
      existDocument.setCreatedAt(System.currentTimeMillis());
      /*
       * Since the previous version could be uploaded by user,
       * reset the name to ensure the newly generated file will not use the name from uploaded file.
       */
      existDocument.setName(documentType.getName() + ".pdf");
      existDocument.setAutoGenerated(true);
      existDocument.setFileType("pdf");

      documentMapper.update(existDocument);
      return existDocument.getId();
    } else {
      Document newDocument =
          Document.builder()
              .userId(userId)
              .caseId(caseId)
              .identify("applicant")
              .status(TaskStatus.IN_PROGRESS.getValue())
              .type(documentType.getName())
              .fileType("pdf")
              .name(documentType.getName() + ".pdf")
              .createdBy(Role.SYSTEM.getValue())
              .generationType(generationType.getValue())
              .autoGenerated(true)
              .manualOverridden(false)
              .createdAt(System.currentTimeMillis())
              .updatedAt(System.currentTimeMillis())
              .build();
      System.out.println("newDocument: " + newDocument);
      documentMapper.create(newDocument);
      return newDocument.getId();
    }
  }

  public Document createOrUpdateDocument(
      Optional<Document> document,
      Long caseId,
      Integer userId,
      DocumentType documentType,
      GenerationType generationType,
      Identify identify) {
    if (document.isPresent()) {
      Document existDocument = document.get();

      existDocument.setStatus(TaskStatus.IN_PROGRESS.getValue());
      existDocument.setUpdatedAt(System.currentTimeMillis());
      existDocument.setCreatedAt(System.currentTimeMillis());
      existDocument.setCreatedBy(Role.SYSTEM.getValue());
      existDocument.setGenerationType(generationType.getValue());
      existDocument.setManualOverridden(false);
      existDocument.setCreatedAt(System.currentTimeMillis());
      /*
       * Since the previous version could be uploaded by user,
       * reset the name to ensure the newly generated file will not use the name from uploaded file.
       */
      existDocument.setName(documentType.getName() + ".pdf");
      existDocument.setAutoGenerated(true);
      existDocument.setFileType("pdf");

      documentMapper.update(existDocument);
      return existDocument;
    } else {
      String name =
          identify == Identify.Applicant
              ? documentType.getName() + ".pdf"
              : String.format("%s_%s.pdf", documentType.getName(), identify.getValue());
      Document newDocument =
          Document.builder()
              .userId(userId)
              .caseId(caseId)
              .identify(identify.getValue())
              .status(TaskStatus.IN_PROGRESS.getValue())
              .type(documentType.getName())
              .fileType("pdf")
              .name(name)
              .createdBy(Role.SYSTEM.getValue())
              .generationType(generationType.getValue())
              .autoGenerated(true)
              .manualOverridden(false)
              .createdAt(System.currentTimeMillis())
              .updatedAt(System.currentTimeMillis())
              .build();
      System.out.println("newDocument: " + newDocument);
      documentMapper.create(newDocument);
      return newDocument;
    }
  }

  public Long markDocumentAsFailed(Optional<Document> document) {
    Document existDocument = document.get();
    existDocument.setStatus(TaskStatus.FAILED.getValue());
    existDocument.setUpdatedAt(System.currentTimeMillis());
    existDocument.setCreatedBy(Role.SYSTEM.getValue());
    documentMapper.update(existDocument);
    return existDocument.getId();
  }

  @Deprecated
  public Long updateDocumentWithError(Optional<Document> document, String error) {
    Document existDocument = document.get();
    existDocument.setStatus(TaskStatus.FAILED.getValue());
    existDocument.setUpdatedAt(System.currentTimeMillis());
    existDocument.setCreatedBy(Role.SYSTEM.getValue());
    DocumentInfo documentInfo;
    if (existDocument.getInfo() != null && !existDocument.getInfo().isEmpty()) {
      documentInfo = new Gson().fromJson(existDocument.getInfo(), DocumentInfo.class);
      documentInfo.setError(DocumentError.builder().source("Server").message(error).build());
    } else {
      documentInfo =
          DocumentInfo.builder()
              .error(DocumentError.builder().source("Server").message(error).build())
              .build();
    }
    existDocument.setInfo(new Gson().toJson(documentInfo));
    documentMapper.update(existDocument);
    return existDocument.getId();
  }

  public Long updateDocumentWithFailure(Document document, String error) {
    document.setStatus(TaskStatus.FAILED.getValue());
    document.setUpdatedAt(System.currentTimeMillis());
    document.setCreatedBy(Role.SYSTEM.getValue());
    DocumentInfo documentInfo;
    if (document.getInfo() != null && !document.getInfo().isEmpty()) {
      documentInfo = new Gson().fromJson(document.getInfo(), DocumentInfo.class);
      documentInfo.setError(DocumentError.builder().source("Server").message(error).build());
    } else {
      documentInfo =
          DocumentInfo.builder()
              .error(DocumentError.builder().source("Server").message(error).build())
              .build();
    }
    document.setInfo(new Gson().toJson(documentInfo));
    documentMapper.update(document);
    return document.getId();
  }

  public String fetchDocumentsAndZipFiles(Long caseId, GenerationType generationType) {
    List<Document> documents =
        documentMapper.list(
            caseId, null, Identify.Applicant.getValue(), null, generationType.getValue());
    System.out.println("documents to be zipped and downloaded: " + documents);
    String s3Key = s3Service.fetchDocumentsAndZipFiles(generatedDocumentBucket, documents);
    return s3Service.generatePresignedUrlForDownload(generatedDocumentBucket, s3Key);
  }
}
